#给定n个物品，第i个物品的重量为wgt[i-1],价值为 val[i-1]，和一个容量为 cap的背包。
# 每个物品只能选择一次，但可以选择物品的一部分，价值根据选择的重量比例计算，问在限定背包容量下能放入物品的最大价值。
#也就是对比0-1背包问题，现在使用的是单位价值val[i-1]/wgt[i-1]

#最大化背包内物品总价值，本质上是最大化单位重量下的物品价值。由此便可推理出图 15-5 所示的贪心策略。

#1.将物品按照单位价值从高到低进行排序。
#2.遍历所有物品，每轮贪心地选择单位价值最高的物品。
#3.若剩余背包容量不足，则使用当前物品的一部分填满背包。
class Item:
    """物品"""

    def __init__(self, w: int, v: int):
        self.w = w  # 物品重量
        self.v = v  # 物品价值

def fractional_knapsack(wgt: list[int], val: list[int], cap: int) -> int:
    """分数背包：贪心"""
    # 创建物品列表，包含两个属性：重量、价值,注意这里的zip用法
    items = [Item(w, v) for w, v in zip(wgt, val)]
    # 按照单位价值 item.v / item.w 从高到低进行排序，这里用法很高级
    items.sort(key=lambda item: item.v / item.w, reverse=True)
    # 循环贪心选择
    res = 0
    for item in items:
        if item.w < cap:
            res += item.v
            cap -= item.v
        else:
            res += (item.v / item.w) * cap
            break
    return res

"""Driver Code"""
if __name__ == "__main__":
    wgt = [10, 20, 30, 40, 50]
    val = [50, 120, 150, 210, 240]
    cap = 50
    n = len(wgt)
    # 贪心算法
    res = fractional_knapsack(wgt, val, cap)
    print(f"不超过背包容量的最大物品价值为 {res}")
