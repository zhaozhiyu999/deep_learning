#给定一个正整数n，将其切分为至少两个正整数的和，求切分后所有整数的乘积最大是多少?
#思路：切成m份，看如何切，然后把这些数字乘起来最大
#确定贪心策略，只要能乘一个2，那就比原来2 + （n-2）要大（当然n>4是前提，n<4时候就只切分1次）
#如果切分方案中包含>=4的因子，那么它就应该被继续切分。最终的切分方案只应出现1.2.3这三种因子。
#然后考虑哪个因子最优，肯定1是最差，毕竟切出来就乘机不变，被乘数还少了1
#然后切分的方案，最多只应该有两个2因子，毕竟三个2因子就是两个3因子，9>8
#综上所述，可推理出以下贪心策略。

#1.输入整数n，从其不断地切分出因子3，直至余数为 0、1、2。
#2.当余数为 0时，代表 n是 3的倍数，因此不做任何处理。
#3.当余数为 2时，不继续划分，保留。
#4.当余数为 1时，由于 2*2>3*1，因此应将最后一个3替换为2,且让最后一个1变成2

def max_product_cutting(n: int) -> int:
    """最大切分乘积：贪心"""
    # 当 n <= 3 时，必须切分出一个 1
    if n<= 3:
        return 1*(n-1)
    # 贪心地切分出 3 ，a 为 3 的个数，b 为余数
    a, b = n//3, n%3
    if b == 0:
        return 3**a
    elif b == 2:
        return (3**a) * 2
    else:
        return (3**(a-1))*2*2

if __name__ == "__main__":
    n1 = 12
    res1 = max_product_cutting(n1)
    n2 = 13
    res2 = max_product_cutting(n2)
    n3 = 17
    res3 = max_product_cutting(n3)
    print(f"切分后最大乘积是{res1}")
    print(f"切分后最大乘积是{res2}")
    print(f"切分后最大乘积是{res3}")
